!pip install -q kaggle
!pip install tensorflow==1.15
!pip install tensorflow_hub>=0.6.0
!pip3 install tensorflow_text==1.15

import tensorflow as tf
import tensorflow_hub as hub
import pandas as pd
import numpy as np
import re
import keras
from keras import backend as K
from keras.models import Model
from keras.layers import Dense, Embedding, Input
from keras.layers import LSTM, Bidirectional, GlobalMaxPool1D, Dropout, Lambda
from keras.preprocessing import text, sequence
from sklearn.metrics import roc_auc_score

#Upload data
from google.colab import files
files.upload()

!mkdir ~/.kaggle
!cp /content/kaggle.json ~/.kaggle/kaggle.json

!kaggle competitions download -c jigsaw-toxic-comment-classification-challenge

! unzip train.csv.zip
! unzip test.csv.zip
! unzip test_labels.csv.zip
! unzip sample_submission.csv.zip

train = pd.read_csv('train.csv',sep = ',', encoding= 'utf-8', error_bad_lines= False)
test = pd.read_csv('test.csv',sep = ',', encoding= 'utf-8', error_bad_lines= False)
test_labels = pd.read_csv('test_labels.csv',sep = ',', encoding= 'utf-8', error_bad_lines= False)
sample_s = pd.read_csv('sample_submission.csv',sep = ',', encoding= 'utf-8', error_bad_lines= False)

X_train = train.iloc[:10000,1:2].values
X_train = np.reshape(X_train,10000)
Y_train = train.iloc[:10000,2:].values
list_classes = ['toxic','severe_toxic','obscene','threat','insult','identity_hate']
x_test = train.iloc[10000:11000,1:2].values
x_test = np.reshape(x_test,1000)
y_true = train.iloc[10000:11000,2:].values

#Model building
elmo = hub.Module("https://tfhub.dev/google/elmo/3", trainable=True)

def ELMoEmbedding(x):
  return elmo(tf.squeeze(tf.cast(x, tf.string)), signature="default", as_dict=True)["default"]
  
def model_elmo1():
  input_text = Input(shape=(1,), dtype='string')
  embedding = Lambda(ELMoEmbedding, output_shape=(1024, ))(input_text)
  dense = Dense(256, activation = 'relu', kernel_regularizer = keras.regularizers.l2(0.001))(embedding)
  drop = Dropout(0.3)(dense)
  pred = Dense(len(list_classes), activation = 'softmax')(drop)
  model = Model(inputs=[input_text], outputs=pred)
  model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])
  return model
model_elmo = model_elmo1()

model_elmo.summary()

#Model train
with tf.Session() as session:
  K.set_session(session)
  session.run(tf.global_variables_initializer())
  session.run(tf.tables_initializer())
  history = model_elmo.fit(X_train, Y_train, epochs = 1,batch_size = 16, validation_split = 0.2) 
  model_elmo.save_weights('./model_elmo_weights.h5')
  
#Model predict
with tf.Session() as session:
  K.set_session(session)
  session.run(tf.global_variables_initializer())
  session.run(tf.tables_initializer())
  model_elmo.load_weights('./model_elmo_weights.h5')
  y_pred = model_elmo.predict(x_test, batch_size = 16)
  
y_true = np.asarray(y_true, dtype= np.float32)
y_pred1 = np.asarray(y_pred, dtype= np.float32)

for i in range(len(list_classes)):
  if i!=3:
    roc = roc_auc_score(y_true[:,i],y_pred1[:,i])
  print(f"ROC_AUC {list_classes[i]}: {roc}")
